#!/usr/bin/env python

from __future__ import division,print_function,unicode_literals
from geode.value import parser
from geode import *
from fractal_helper import *
from collections import defaultdict
import sys

# Depth 4:
#   ./poincare --mode flop --tolerance 1e-3 --depth 4 --separation .05

# Properties
props = PropManager()
mode = props.add('mode','disk').set_allowed('disk flop test'.split())
depth = props.add('depth',3)
resolution = props.add('resolution',20)
tolerance = props.add('tolerance',1e-2)
separation = props.add('separation',.8)
parser.parse(props,'Hyperbolic triangulation layout',)

c2r_dtype = {dtype(complex64):dtype(float32),dtype(complex128):dtype(float64)}
def splitcomplex(z):
  w = empty(z.shape+(2,),dtype=c2r_dtype[z.dtype])
  mergecomplex(w)[...] = z
  return w

r2c_dtype = {dtype(float32):dtype(complex64),dtype(float64):dtype(complex128)}
def mergecomplex(z):
  z = asarray(z)
  assert z.shape[-1]==2
  return z.view(r2c_dtype[z.dtype]).reshape(z.shape[:-1])

def distance(u,v=zeros(2)):
  # See http://en.wikipedia.org/wiki/Poincare_disk
  return acosh(1+2*sqr_magnitudes(u-v)/((1-sqr_magnitudes(u)*(1-sqr_magnitudes(v)))))

class Mobius(ndarray):
  # Mobius group theory:
  #   w = (az+b)/(cz+d)
  # When does f(z) preserve the unit circle?
  #   http://math.stackexchange.com/questions/34071/mobius-transforms-that-preserve-the-unit-disk
  #   f(z) = r (z+a)/(1+a'z)
  #   g(z) = s (z+b)/(1+b'z)
  #   f(g(z)) = r (s(z+b)/(1+b'z)+a) / (1 + a's(z+b)/(1+b'z))
  #           = r (s(z+b)+a(1+b'z)) / (1+b'z + a's(z+b))
  #           = r ((s+ab')z + sb+a) / (1+sa'b + (b'+sa')z)
  #           = rs ((1+s'ab')z + b+s'a) / (1+sa'b + (b+s'a)'z)
  # Let t = (1+s'ab')/(1+sa'b), so that |t| = 1.  Let c = (b+s'a)/(1+s'ab').  We have
  #   f(g(z)) = rst (z+c)/(1+c'z)

  __array_priority__ = -1.

  def __array_finalize__(self,*args):
    '''View the 2x2 complex matrices m as Mobius transforms.
    With no arguments, return a single identity transform.'''
    assert iscomplexobj(self)
    assert self.shape[-2:]==(2,2)

  def __mul__(self,z):
    if isinstance(z,Mobius):
      if 0:
        a = self.view(ndarray)[...,None]
        b = z.reshape(z.shape[:-2]+(1,2,2))
        print('A\n',self.view(ndarray))
        print('B\n',b)
        print('AB\n',multiply(a,b).sum(axis=-2))
      return multiply(self.view(ndarray)[...,None],z.reshape(z.shape[:-2]+(1,2,2))).sum(axis=-2).view(Mobius)
    else:
      z = mergecomplex(z)
      a,b,c,d = rollaxis(self.view(ndarray).reshape(self.shape[:-2]+(4,)),-1)
      return splitcomplex((a*z+b)/(c*z+d))

  def inverse(self):
    a,b,c,d = rollaxis(self.view(ndarray).reshape(self.shape[:-2]+(4,)),-1)
    i = empty(self.shape,self.dtype)
    i[...,0,0] = d
    i[...,0,1] = -b
    i[...,1,0] = -c
    i[...,1,1] = a
    return (i/(a*d-b*c)[...,None,None]).view(Mobius)

  def normalized(self):
    a,b,c,d = rollaxis(self.view(ndarray).reshape(self.shape[:-2]+(4,)),-1)
    return self/sqrt(a*d-b*c)[...,None,None]

  @staticmethod
  def identity(dtype=complex128):
    return eye(2,dtype=dtype).view(Mobius)

  @staticmethod
  def from_angle(t):
    t = asarray(t)
    m = zeros(t.shape+(2,2,2),t.dtype)
    m[...,0,0,:] = polar(t)
    m[...,1,1,0] = 1
    return mergecomplex(m).view(Mobius)

  @staticmethod
  def translation(u):
    "Walk the origin distance |u| in direction u/|u|"
    d,u = magnitudes_and_normalized(u)
    # Build rotations by u and conj(u)
    u = mergecomplex(u)
    # Here is how far the origin will go in the Poincare disk:
    #   distance(v,0) = d
    #   acosh(1+2v'v/(1-v'v)) = d
    #   1+2v'v/(1-v'v) = cosh(d)
    #   v'v/(1-v'v) = (cosh(d)-1)/2 = b
    #   v'v = b/(1+b)
    b = (cosh(d)-1)/2
    vv = b/(1+b)
    v = sqrt(vv)
    # If u is real, our Mobius transform will look like
    #   f(z) = r (z+a)/(1+a'z)
    #   f(1) = r (1+a)/(1+a') = 1
    #   v = f(0) = r a
    #   a = v
    #   r = 1
    #   f(z) = (z+v)/(vz+1)
    # If u is not real, we pre and post rotate:
    #   f(z) = u(u'z+v)/(u'vz+1) = (z+uv)/(u'vz+1)
    # Assemble transform
    m = empty(d.shape+(2,2),dtype=u.dtype)
    m[...,0,0] = 1
    m[...,0,1] = u*v
    m[...,1,0] = conj(u)*v
    m[...,1,1] = 1
    return m.view(Mobius)

  def __str__(self):
    return str(self.view(ndarray))

  def __repr__(self):
    return repr(self.view(ndarray))

  @staticmethod
  def empty(shape,dtype=complex128):
    if not isinstance(shape,tuple):
      shape = shape,
    return empty(shape+(2,2),dtype).view(Mobius)

  @staticmethod
  def concat(*args):
    return concatenate([a.view(ndarray) for a in args]).view(Mobius)

  @staticmethod
  def close(x,y=None):
    y = Mobius.identity() if y is None else y.normalized()
    return allclose(x.normalized(),y)

def test_mobius():
  random.seed(821)
  # Rotations
  v = (.2,.2)
  theta = random.randn()
  r = Mobius.from_angle(theta)
  assert allclose(r*v,Rotation.from_angle(theta)*v)
  # Translations
  u = random.randn(2)
  t = Mobius.translation(u)
  tf = Mobius.translation(-u)
  assert allclose(distance(t*zeros(2)),magnitude(u))
  assert allclose(angle_between(t*zeros(2),u),0)
  # Inverses
  m = Mobius.translation(u)*Mobius.translation(random.randn(2))
  assert Mobius.close(m*m.inverse())
  assert Mobius.close(m.inverse()*m)
  # Identities
  f = Mobius.from_angle(pi)
  assert Mobius.close(t*tf)
  assert Mobius.close(t*f,f*tf)
  assert Mobius.close(t*t,Mobius.translation(2*u))

def equilateral_length_from_angle(t):
  # The hyperbolic law of cosines for angle t, side s is
  #   cos t = -cos^2 t + sin^2 t cosh a
  #   a = acosh (cos(t)*(1+cos(t))/sin(t)^2)
  c,s = cos(t),sin(t)
  return acosh(c*(1+c)/(s*s))

@cache
def lattice():
  '''Compute lattice points and transforms of the standard 7-valent triangulation
  of the Poincare disk model of the hyperbolic plane.'''
  a = 2*pi/7
  advance = Mobius.translation((equilateral_length_from_angle(a),0))*Mobius.from_angle(pi)
  rotate = Mobius.from_angle(a*arange(7))
  levels = [rotate]
  for d in xrange(depth()):
    next = ((rotate*advance)[:,None]*levels[-1]).reshape(-1,2,2)
    levels.append(((rotate*advance)[:,None]*levels[-1]).reshape(-1,2,2))
  trans = Mobius.concat(*levels)
  # Prune duplicates
  compact = ParticleTree(trans*zeros(2),1).remove_duplicates(1e-7)
  trans = trans[unique(compact,return_index=1)[1]]
  print('count = %d'%len(trans))
  return trans

@cache
def lattice_edges():
  trans = lattice()
  n = resolution()
  a = 2*pi/7
  tree = ParticleTree(trans*zeros(2),1)
  step = equilateral_length_from_angle(a)
  walks = Mobius.translation(linspace(1e-50,step,n)[:,None]*polar(a*arange(7))[:,None])
  edges = []
  paths = []
  for i,m in enumerate(trans):
    for walk in walks:
      p = m*walk[-1]*zeros(2)
      cp,j = tree.closest_point(p,1e-7)
      if all(isfinite(cp)) and distance(p,cp)<.1:
        edges.append((i,j))
        paths.append(m*walk*zeros(2))
  return asarray(edges,dtype=int32),tuple(paths)

@cache
def lattice_mesh():
  X = lattice()*zeros(2)
  edges,_ = lattice_edges()
  near = defaultdict(lambda:set())
  for x,y in edges:
    near[x].add(y)
    near[y].add(x)
  tris = set()
  for x,y in edges:
    for z in near[x]:
      if z in near[y]:
        a,b,c = sorted((x,y,z))
        if cross(X[b]-X[a],X[c]-X[a])<0:
          b,c = c,b
        tris.add((a,b,c))
  return TriangleSoup(sorted(tris))

@cache
def flopsolve():
  X0 = lattice()*zeros(2)
  n = len(X0)
  edges,_ = lattice_edges()
  def lengths(X):
    return magnitudes(X[edges[:,1]]-X[edges[:,0]])

  # Scale so that the average edge length is 1
  X0 /= lengths(X0).mean()
  # Move to 3D
  X0 = hstack([X0,zeros(n)[:,None]])
  # Apply some noise so that everything doesn't start in the plane
  random.seed(8231110)
  X0 += .1*random.randn(n,3)

  # Define problem
  close = separation()
  stiff = 10
  collisions = SimpleCollisions(lattice_mesh(),close,True)
  def energy(X):
    X = X.reshape(-1,3)
    L = sqr_magnitude(lengths(X)-1)/2
    C = stiff*collisions.energy(X)
    print ('energies: L = %g, C = %g'%(L,C))
    return L+C
  def gradient(X):
    X = X.reshape(-1,3)
    G = unit_spring_energy_gradient(edges,X)+stiff*collisions.gradient(X)
    return G.ravel()

  # Test
  dX = 1e-7*random.randn(n,3)
  X = random.randn(n,3)
  numerical = energy(X+dX)-energy(X-dX)
  analytic = 2*dot(gradient(X),dX.ravel())
  error = relative_error(numerical,analytic)
  print('numerical = %g, analytic = %g, error = %g'%(numerical,analytic,error))
  assert error<1e-5

  # Solve
  import scipy.optimize
  result = scipy.optimize.minimize(energy,X0.ravel(),jac=gradient,tol=tolerance())
  X = result.x.reshape(-1,3)
  print('energy = %g'%energy(X))
  L = lengths(X)
  lo,hi = L.min(),L.max()
  print('length range = %g %g (width %g)'%(lo,hi,hi-lo))
  print('closest = %g'%collisions.closest(X))
  print('collisions = %d'%collisions.collisions(X))
  return X

def flop():
  import gui
  app = gui.QEApp(sys.argv,True)
  main = gui.MainWindow(props)
  main.view.add_scene('mesh',gui.MeshScene(props,lattice_mesh,flopsolve,(.2,.2,1),(0,1,0)))
  def save_mesh():
    tm = TriMesh()
    tm.add_vertices(flopsolve())
    tm.add_faces(lattice_mesh().elements)
    tm.write('poincare.stl')
  main.add_menu_item('File','Save',save_mesh,'')
  main.init()
  app.run()

def plot():
  import pylab
  trans = lattice()
  # Draw vertices
  points = trans*zeros(2)
  print('points %s'%(points.shape,))
  pylab.plot(points[:,0],points[:,1],'o')
  # Draw edges
  edges,paths = lattice_edges()
  for path in paths:
    pylab.plot(path[:,0],path[:,1],'g')
  # Show
  pylab.axes().set_aspect('equal')
  pylab.show()

if __name__=='__main__':
  test_mobius()
  if mode()=='disk':
    plot()
  elif mode()=='flop':
    flop()
  elif mode()!='test':
    raise NotImplementedError("unknown mode '%s'"%mode())
